\hypertarget{_thread_pool_8hpp_source}{}\doxysection{Thread\+Pool.\+hpp}
\label{_thread_pool_8hpp_source}\index{C:/Users/lllll/Documents/GitHub/UniEngine/include/lib/Engine/Core/ThreadPool.hpp@{C:/Users/lllll/Documents/GitHub/UniEngine/include/lib/Engine/Core/ThreadPool.hpp}}
\mbox{\hyperlink{_thread_pool_8hpp}{Go to the documentation of this file.}}
\begin{DoxyCode}{0}
\DoxyCodeLine{1 \textcolor{preprocessor}{\#pragma once}}
\DoxyCodeLine{2 \textcolor{keyword}{namespace }\mbox{\hyperlink{namespace_uni_engine}{UniEngine}}}
\DoxyCodeLine{3 \{}
\DoxyCodeLine{4 \textcolor{keyword}{namespace }detail}
\DoxyCodeLine{5 \{}
\DoxyCodeLine{6 \textcolor{keyword}{template} <\textcolor{keyword}{typename} T> \textcolor{keyword}{class }\mbox{\hyperlink{class_uni_engine_1_1detail_1_1_thread_queue}{ThreadQueue}}}
\DoxyCodeLine{7 \{}
\DoxyCodeLine{8   \textcolor{keyword}{public}:}
\DoxyCodeLine{9     \textcolor{keywordtype}{bool} \mbox{\hyperlink{class_uni_engine_1_1detail_1_1_thread_queue_a0ac3e5a520fbd633a7f9448c34d75505}{push}}(T \textcolor{keyword}{const} \&value)}
\DoxyCodeLine{10     \{}
\DoxyCodeLine{11         std::unique\_lock<std::mutex> lock(this-\/>mutex);}
\DoxyCodeLine{12         this-\/>q.push(value);}
\DoxyCodeLine{13         \textcolor{keywordflow}{return} \textcolor{keyword}{true};}
\DoxyCodeLine{14     \}}
\DoxyCodeLine{15     \textcolor{comment}{// deletes the retrieved element, do not use for non integral types}}
\DoxyCodeLine{16     \textcolor{keywordtype}{bool} \mbox{\hyperlink{class_uni_engine_1_1detail_1_1_thread_queue_a96022683fc667dbf3ba094aa938cc13a}{pop}}(T \&v)}
\DoxyCodeLine{17     \{}
\DoxyCodeLine{18         std::unique\_lock<std::mutex> lock(this-\/>mutex);}
\DoxyCodeLine{19         \textcolor{keywordflow}{if} (this-\/>q.empty())}
\DoxyCodeLine{20             \textcolor{keywordflow}{return} \textcolor{keyword}{false};}
\DoxyCodeLine{21         v = this-\/>q.front();}
\DoxyCodeLine{22         this-\/>q.pop();}
\DoxyCodeLine{23         \textcolor{keywordflow}{return} \textcolor{keyword}{true};}
\DoxyCodeLine{24     \}}
\DoxyCodeLine{25     \textcolor{keywordtype}{bool} \mbox{\hyperlink{class_uni_engine_1_1detail_1_1_thread_queue_abace08db1d0ef0fbba2dbcb2904632a2}{empty}}()}
\DoxyCodeLine{26     \{}
\DoxyCodeLine{27         std::unique\_lock<std::mutex> lock(this-\/>mutex);}
\DoxyCodeLine{28         \textcolor{keywordflow}{return} this-\/>q.empty();}
\DoxyCodeLine{29     \}}
\DoxyCodeLine{30 }
\DoxyCodeLine{31   \textcolor{keyword}{private}:}
\DoxyCodeLine{32     std::queue<T> q;}
\DoxyCodeLine{33     std::mutex mutex;}
\DoxyCodeLine{34 \};}
\DoxyCodeLine{35 \} \textcolor{comment}{// namespace detail}}
\DoxyCodeLine{36 }
\DoxyCodeLine{37 \textcolor{keyword}{class }\mbox{\hyperlink{class_uni_engine_1_1_thread_pool}{ThreadPool}}}
\DoxyCodeLine{38 \{}
\DoxyCodeLine{39 }
\DoxyCodeLine{40   \textcolor{keyword}{public}:}
\DoxyCodeLine{41     \mbox{\hyperlink{class_uni_engine_1_1_thread_pool_a090672fb0d43d98c5abd0aa993473f6d}{ThreadPool}}()}
\DoxyCodeLine{42     \{}
\DoxyCodeLine{43         this-\/>Init();}
\DoxyCodeLine{44     \}}
\DoxyCodeLine{45     \mbox{\hyperlink{class_uni_engine_1_1_thread_pool_a6125f74f5173003a99487d3355334ce4}{ThreadPool}}(\textcolor{keywordtype}{int} nThreads)}
\DoxyCodeLine{46     \{}
\DoxyCodeLine{47         this-\/>Init();}
\DoxyCodeLine{48         this-\/>\mbox{\hyperlink{class_uni_engine_1_1_thread_pool_af5dcc29c377fe710c4505dd844c1b065}{Resize}}(nThreads);}
\DoxyCodeLine{49     \}}
\DoxyCodeLine{50 }
\DoxyCodeLine{51     \textcolor{comment}{// the destructor waits for all the functions in the queue to be finished}}
\DoxyCodeLine{52     \mbox{\hyperlink{class_uni_engine_1_1_thread_pool_a2d231c40cebd62d470491331fd887a8e}{\string~ThreadPool}}()}
\DoxyCodeLine{53     \{}
\DoxyCodeLine{54         this-\/>\mbox{\hyperlink{class_uni_engine_1_1_thread_pool_af96595063b4c09cd6ec369b027db6727}{FinishAll}}(\textcolor{keyword}{true});}
\DoxyCodeLine{55     \}}
\DoxyCodeLine{56 }
\DoxyCodeLine{57     \textcolor{comment}{// get the number of running threads in the pool}}
\DoxyCodeLine{58     \textcolor{keywordtype}{int} \mbox{\hyperlink{class_uni_engine_1_1_thread_pool_a9a0eda36af0e6fea899b761810863142}{Size}}()\textcolor{keyword}{ const}}
\DoxyCodeLine{59 \textcolor{keyword}{    }\{}
\DoxyCodeLine{60         \textcolor{keywordflow}{return} \textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{int}\textcolor{keyword}{>}(this-\/>m\_threads.size());}
\DoxyCodeLine{61     \}}
\DoxyCodeLine{62 }
\DoxyCodeLine{63     \textcolor{comment}{// number of idle threads}}
\DoxyCodeLine{64     \textcolor{keywordtype}{int} \mbox{\hyperlink{class_uni_engine_1_1_thread_pool_acbab856f91b92e0e2ad83d050a3c158a}{IdleAmount}}()\textcolor{keyword}{ const}}
\DoxyCodeLine{65 \textcolor{keyword}{    }\{}
\DoxyCodeLine{66         \textcolor{keywordflow}{return} this-\/>m\_waitingThreadAmount;}
\DoxyCodeLine{67     \}}
\DoxyCodeLine{68     std::thread \&\mbox{\hyperlink{class_uni_engine_1_1_thread_pool_ae6e4124c0b045ee089410b74287318e2}{GetThread}}(\textcolor{keywordtype}{int} i)}
\DoxyCodeLine{69     \{}
\DoxyCodeLine{70         \textcolor{keywordflow}{return} *this-\/>m\_threads[i];}
\DoxyCodeLine{71     \}}
\DoxyCodeLine{72 }
\DoxyCodeLine{73     \textcolor{comment}{// change the number of threads in the pool}}
\DoxyCodeLine{74     \textcolor{comment}{// should be called from one thread, otherwise be careful to not interleave, also with this-\/>stop()}}
\DoxyCodeLine{75     \textcolor{comment}{// nThreads must be >= 0}}
\DoxyCodeLine{76     \textcolor{keywordtype}{void} \mbox{\hyperlink{class_uni_engine_1_1_thread_pool_af5dcc29c377fe710c4505dd844c1b065}{Resize}}(\textcolor{keywordtype}{int} nThreads)}
\DoxyCodeLine{77     \{}
\DoxyCodeLine{78         \textcolor{keywordflow}{if} (!this-\/>m\_isStop \&\& !this-\/>m\_isDone)}
\DoxyCodeLine{79         \{}
\DoxyCodeLine{80             \textcolor{keywordtype}{int} oldNThreads = \textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{int}\textcolor{keyword}{>}(this-\/>m\_threads.size());}
\DoxyCodeLine{81             \textcolor{keywordflow}{if} (oldNThreads <= nThreads)}
\DoxyCodeLine{82             \{ \textcolor{comment}{// if the number of threads is increased}}
\DoxyCodeLine{83                 this-\/>m\_threads.resize(nThreads);}
\DoxyCodeLine{84                 this-\/>m\_flags.resize(nThreads);}
\DoxyCodeLine{85 }
\DoxyCodeLine{86                 \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} i = oldNThreads; i < nThreads; ++i)}
\DoxyCodeLine{87                 \{}
\DoxyCodeLine{88                     this-\/>m\_flags[i] = std::make\_shared<std::atomic<bool>>(\textcolor{keyword}{false});}
\DoxyCodeLine{89                     this-\/>SetThread(i);}
\DoxyCodeLine{90                 \}}
\DoxyCodeLine{91             \}}
\DoxyCodeLine{92             \textcolor{keywordflow}{else}}
\DoxyCodeLine{93             \{ \textcolor{comment}{// the number of threads is decreased}}
\DoxyCodeLine{94                 \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} i = oldNThreads -\/ 1; i >= nThreads; -\/-\/i)}
\DoxyCodeLine{95                 \{}
\DoxyCodeLine{96                     *this-\/>m\_flags[i] = \textcolor{keyword}{true}; \textcolor{comment}{// this thread will finish}}
\DoxyCodeLine{97                     this-\/>m\_threads[i]-\/>detach();}
\DoxyCodeLine{98                 \}}
\DoxyCodeLine{99                 \{}
\DoxyCodeLine{100                     \textcolor{comment}{// stop the detached threads that were waiting}}
\DoxyCodeLine{101                     std::unique\_lock<std::mutex> lock(this-\/>m\_mutex);}
\DoxyCodeLine{102                     this-\/>m\_threadPoolCondition.notify\_all();}
\DoxyCodeLine{103                 \}}
\DoxyCodeLine{104                 this-\/>m\_threads.resize(nThreads); \textcolor{comment}{// safe to delete because the threads are detached}}
\DoxyCodeLine{105                 this-\/>m\_flags.resize(nThreads);   \textcolor{comment}{// safe to delete because the threads have copies of shared\_ptr of the}}
\DoxyCodeLine{106                                                   \textcolor{comment}{// flags, not originals}}
\DoxyCodeLine{107             \}}
\DoxyCodeLine{108         \}}
\DoxyCodeLine{109     \}}
\DoxyCodeLine{110 }
\DoxyCodeLine{111     \textcolor{comment}{// empty the queue}}
\DoxyCodeLine{112     \textcolor{keywordtype}{void} \mbox{\hyperlink{class_uni_engine_1_1_thread_pool_a9a7c346470b4accbd20a329f9c512e68}{ClearQueue}}()}
\DoxyCodeLine{113     \{}
\DoxyCodeLine{114         std::function<void(\textcolor{keywordtype}{int} \textcolor{keywordtype}{id})> *\_f;}
\DoxyCodeLine{115         \textcolor{keywordflow}{while} (this-\/>m\_threadPool.pop(\_f))}
\DoxyCodeLine{116             \textcolor{keyword}{delete} \_f; \textcolor{comment}{// empty the queue}}
\DoxyCodeLine{117     \}}
\DoxyCodeLine{118 }
\DoxyCodeLine{119     \textcolor{comment}{// pops a functional wrapper to the original function}}
\DoxyCodeLine{120     std::function<void(\textcolor{keywordtype}{int})> \mbox{\hyperlink{class_uni_engine_1_1_thread_pool_afaef20047ac18d3b9acecab83d70ed64}{Pop}}()}
\DoxyCodeLine{121     \{}
\DoxyCodeLine{122         std::function<void(\textcolor{keywordtype}{int} \textcolor{keywordtype}{id})> *\_f = \textcolor{keyword}{nullptr};}
\DoxyCodeLine{123         this-\/>m\_threadPool.pop(\_f);}
\DoxyCodeLine{124         std::unique\_ptr<std::function<void(\textcolor{keywordtype}{int} \textcolor{keywordtype}{id})>> func(}
\DoxyCodeLine{125             \_f); \textcolor{comment}{// at return, delete the function even if an exception occurred}}
\DoxyCodeLine{126         std::function<void(\textcolor{keywordtype}{int})> f;}
\DoxyCodeLine{127         \textcolor{keywordflow}{if} (\_f)}
\DoxyCodeLine{128             f = *\_f;}
\DoxyCodeLine{129         \textcolor{keywordflow}{return} f;}
\DoxyCodeLine{130     \}}
\DoxyCodeLine{131 }
\DoxyCodeLine{132     \textcolor{comment}{// wait for all computing threads to finish and stop all threads}}
\DoxyCodeLine{133     \textcolor{comment}{// may be called asynchronously to not pause the calling thread while waiting}}
\DoxyCodeLine{134     \textcolor{comment}{// if isWait == true, all the functions in the queue are run, otherwise the queue is cleared without running the}}
\DoxyCodeLine{135     \textcolor{comment}{// functions}}
\DoxyCodeLine{136     \textcolor{keywordtype}{void} \mbox{\hyperlink{class_uni_engine_1_1_thread_pool_af96595063b4c09cd6ec369b027db6727}{FinishAll}}(\textcolor{keywordtype}{bool} isWait = \textcolor{keyword}{false})}
\DoxyCodeLine{137     \{}
\DoxyCodeLine{138         \textcolor{keywordflow}{if} (!isWait)}
\DoxyCodeLine{139         \{}
\DoxyCodeLine{140             \textcolor{keywordflow}{if} (this-\/>m\_isStop)}
\DoxyCodeLine{141                 \textcolor{keywordflow}{return};}
\DoxyCodeLine{142             this-\/>m\_isStop = \textcolor{keyword}{true};}
\DoxyCodeLine{143             \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} i = 0, n = this-\/>\mbox{\hyperlink{class_uni_engine_1_1_thread_pool_a9a0eda36af0e6fea899b761810863142}{Size}}(); i < n; ++i)}
\DoxyCodeLine{144             \{}
\DoxyCodeLine{145                 *this-\/>m\_flags[i] = \textcolor{keyword}{true}; \textcolor{comment}{// command the threads to stop}}
\DoxyCodeLine{146             \}}
\DoxyCodeLine{147             this-\/>\mbox{\hyperlink{class_uni_engine_1_1_thread_pool_a9a7c346470b4accbd20a329f9c512e68}{ClearQueue}}(); \textcolor{comment}{// empty the queue}}
\DoxyCodeLine{148         \}}
\DoxyCodeLine{149         \textcolor{keywordflow}{else}}
\DoxyCodeLine{150         \{}
\DoxyCodeLine{151             \textcolor{keywordflow}{if} (this-\/>m\_isDone || this-\/>m\_isStop)}
\DoxyCodeLine{152                 \textcolor{keywordflow}{return};}
\DoxyCodeLine{153             this-\/>m\_isDone = \textcolor{keyword}{true}; \textcolor{comment}{// give the waiting threads a command to finish}}
\DoxyCodeLine{154         \}}
\DoxyCodeLine{155         \{}
\DoxyCodeLine{156             std::unique\_lock<std::mutex> lock(this-\/>m\_mutex);}
\DoxyCodeLine{157             this-\/>m\_threadPoolCondition.notify\_all(); \textcolor{comment}{// stop all waiting threads}}
\DoxyCodeLine{158         \}}
\DoxyCodeLine{159         \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} i = 0; i < static\_cast<int>(this-\/>m\_threads.size()); ++i)}
\DoxyCodeLine{160         \{ \textcolor{comment}{// wait for the computing threads to finish}}
\DoxyCodeLine{161             \textcolor{keywordflow}{if} (this-\/>m\_threads[i]-\/>joinable())}
\DoxyCodeLine{162                 this-\/>m\_threads[i]-\/>join();}
\DoxyCodeLine{163         \}}
\DoxyCodeLine{164         \textcolor{comment}{// if there were no threads in the pool but some functors in the queue, the functors are not deleted by the}}
\DoxyCodeLine{165         \textcolor{comment}{// threads therefore delete them here}}
\DoxyCodeLine{166         this-\/>\mbox{\hyperlink{class_uni_engine_1_1_thread_pool_a9a7c346470b4accbd20a329f9c512e68}{ClearQueue}}();}
\DoxyCodeLine{167         this-\/>m\_threads.clear();}
\DoxyCodeLine{168         this-\/>m\_flags.clear();}
\DoxyCodeLine{169         this-\/>m\_waitingThreadAmount = 0;}
\DoxyCodeLine{170         this-\/>m\_isStop = \textcolor{keyword}{false};}
\DoxyCodeLine{171         this-\/>m\_isDone = \textcolor{keyword}{false};}
\DoxyCodeLine{172     \}}
\DoxyCodeLine{173 }
\DoxyCodeLine{174     \textcolor{keyword}{template} <\textcolor{keyword}{typename} F, \textcolor{keyword}{typename}... Rest> \textcolor{keyword}{auto} \mbox{\hyperlink{class_uni_engine_1_1_thread_pool_a2b643308b00ab39b7871036e012919b3}{Push}}(F \&\&f, Rest \&\&...rest) -\/> std::future<\textcolor{keyword}{decltype}(f(0, rest...))>}
\DoxyCodeLine{175     \{}
\DoxyCodeLine{176         \textcolor{keyword}{auto} pck = std::make\_shared<std::packaged\_task<\textcolor{keyword}{decltype}(f(0, rest...))(\textcolor{keywordtype}{int})>>(}
\DoxyCodeLine{177             std::bind(std::forward<F>(f), std::placeholders::\_1, std::forward<Rest>(rest)...));}
\DoxyCodeLine{178         \textcolor{keyword}{auto} \_f = \textcolor{keyword}{new} std::function<void(int id)>([pck](\textcolor{keywordtype}{int} \textcolor{keywordtype}{id}) \{ (*pck)(id); \});}
\DoxyCodeLine{179         this-\/>m\_threadPool.push(\_f);}
\DoxyCodeLine{180         std::unique\_lock<std::mutex> lock(this-\/>m\_mutex);}
\DoxyCodeLine{181         this-\/>m\_threadPoolCondition.notify\_one();}
\DoxyCodeLine{182         \textcolor{keywordflow}{return} pck-\/>get\_future();}
\DoxyCodeLine{183     \}}
\DoxyCodeLine{184 }
\DoxyCodeLine{185     \textcolor{comment}{// run the user's function that excepts argument int -\/ id of the running thread. returned value is templatized}}
\DoxyCodeLine{186     \textcolor{comment}{// operator returns std::future, where the user can get the result and rethrow the catched exceptins}}
\DoxyCodeLine{187     \textcolor{keyword}{template} <\textcolor{keyword}{typename} F> \textcolor{keyword}{auto} \mbox{\hyperlink{class_uni_engine_1_1_thread_pool_ad3c7fd7c0098f5de88cefc6d50239b7c}{Push}}(F \&\&f) -\/> std::future<\textcolor{keyword}{decltype}(f(0))>}
\DoxyCodeLine{188     \{}
\DoxyCodeLine{189         \textcolor{keyword}{auto} pck = std::make\_shared<std::packaged\_task<\textcolor{keyword}{decltype}(f(0))(\textcolor{keywordtype}{int})>>(std::forward<F>(f));}
\DoxyCodeLine{190         \textcolor{keyword}{auto} \_f = \textcolor{keyword}{new} std::function<void(int id)>([pck](\textcolor{keywordtype}{int} \textcolor{keywordtype}{id}) \{ (*pck)(id); \});}
\DoxyCodeLine{191         this-\/>m\_threadPool.push(\_f);}
\DoxyCodeLine{192         std::unique\_lock<std::mutex> lock(this-\/>m\_mutex);}
\DoxyCodeLine{193         this-\/>m\_threadPoolCondition.notify\_one();}
\DoxyCodeLine{194         \textcolor{keywordflow}{return} pck-\/>get\_future();}
\DoxyCodeLine{195     \}}
\DoxyCodeLine{196 }
\DoxyCodeLine{197   \textcolor{keyword}{private}:}
\DoxyCodeLine{198     \textcolor{comment}{// deleted}}
\DoxyCodeLine{199     \mbox{\hyperlink{class_uni_engine_1_1_thread_pool_a090672fb0d43d98c5abd0aa993473f6d}{ThreadPool}}(\textcolor{keyword}{const} \mbox{\hyperlink{class_uni_engine_1_1_thread_pool}{ThreadPool}} \&);            \textcolor{comment}{// = delete;}}
\DoxyCodeLine{200     \mbox{\hyperlink{class_uni_engine_1_1_thread_pool_a090672fb0d43d98c5abd0aa993473f6d}{ThreadPool}}(\mbox{\hyperlink{class_uni_engine_1_1_thread_pool}{ThreadPool}} \&\&);                 \textcolor{comment}{// = delete;}}
\DoxyCodeLine{201     \mbox{\hyperlink{class_uni_engine_1_1_thread_pool}{ThreadPool}} \&operator=(\textcolor{keyword}{const} \mbox{\hyperlink{class_uni_engine_1_1_thread_pool}{ThreadPool}} \&); \textcolor{comment}{// = delete;}}
\DoxyCodeLine{202     \mbox{\hyperlink{class_uni_engine_1_1_thread_pool}{ThreadPool}} \&operator=(\mbox{\hyperlink{class_uni_engine_1_1_thread_pool}{ThreadPool}} \&\&);      \textcolor{comment}{// = delete;}}
\DoxyCodeLine{203 }
\DoxyCodeLine{204     \textcolor{keywordtype}{void} SetThread(\textcolor{keywordtype}{int} i)}
\DoxyCodeLine{205     \{}
\DoxyCodeLine{206         std::shared\_ptr<std::atomic<bool>> flag(this-\/>m\_flags[i]); \textcolor{comment}{// a copy of the shared ptr to the flag}}
\DoxyCodeLine{207         \textcolor{keyword}{auto} f = [\textcolor{keyword}{this}, i, flag \textcolor{comment}{/* a copy of the shared ptr to the flag */}]() \{}
\DoxyCodeLine{208             std::atomic<bool> \&\_flag = *flag;}
\DoxyCodeLine{209             std::function<void(\textcolor{keywordtype}{int} \textcolor{keywordtype}{id})> *\_f;}
\DoxyCodeLine{210             \textcolor{keywordtype}{bool} isPop = this-\/>m\_threadPool.pop(\_f);}
\DoxyCodeLine{211             \textcolor{keywordflow}{while} (\textcolor{keyword}{true})}
\DoxyCodeLine{212             \{}
\DoxyCodeLine{213                 \textcolor{keywordflow}{while} (isPop)}
\DoxyCodeLine{214                 \{ \textcolor{comment}{// if there is anything in the queue}}
\DoxyCodeLine{215                     std::unique\_ptr<std::function<void(\textcolor{keywordtype}{int} \textcolor{keywordtype}{id})>> func(}
\DoxyCodeLine{216                         \_f); \textcolor{comment}{// at return, delete the function even if an exception occurred}}
\DoxyCodeLine{217                     (*\_f)(i);}
\DoxyCodeLine{218                     \textcolor{keywordflow}{if} (\_flag)}
\DoxyCodeLine{219                         \textcolor{keywordflow}{return}; \textcolor{comment}{// the thread is wanted to stop, return even if the queue is not empty yet}}
\DoxyCodeLine{220                     \textcolor{keywordflow}{else}}
\DoxyCodeLine{221                         isPop = this-\/>m\_threadPool.pop(\_f);}
\DoxyCodeLine{222                 \}}
\DoxyCodeLine{223                 \textcolor{comment}{// the queue is empty here, wait for the next command}}
\DoxyCodeLine{224                 std::unique\_lock<std::mutex> lock(this-\/>m\_mutex);}
\DoxyCodeLine{225                 ++this-\/>m\_waitingThreadAmount;}
\DoxyCodeLine{226                 this-\/>m\_threadPoolCondition.wait(lock, [\textcolor{keyword}{this}, \&\_f, \&isPop, \&\_flag]() \{}
\DoxyCodeLine{227                     isPop = this-\/>m\_threadPool.pop(\_f);}
\DoxyCodeLine{228                     \textcolor{keywordflow}{return} isPop || this-\/>m\_isDone || \_flag;}
\DoxyCodeLine{229                 \});}
\DoxyCodeLine{230                 -\/-\/this-\/>m\_waitingThreadAmount;}
\DoxyCodeLine{231                 \textcolor{keywordflow}{if} (!isPop)}
\DoxyCodeLine{232                     \textcolor{keywordflow}{return}; \textcolor{comment}{// if the queue is empty and this-\/>isDone == true or *flag then return}}
\DoxyCodeLine{233             \}}
\DoxyCodeLine{234         \};}
\DoxyCodeLine{235         this-\/>m\_threads[i].reset(\textcolor{keyword}{new} std::thread(f)); \textcolor{comment}{// compiler may not support std::make\_unique()}}
\DoxyCodeLine{236     \}}
\DoxyCodeLine{237 }
\DoxyCodeLine{238     \textcolor{keywordtype}{void} Init()}
\DoxyCodeLine{239     \{}
\DoxyCodeLine{240         this-\/>m\_waitingThreadAmount = 0;}
\DoxyCodeLine{241         this-\/>m\_isStop = \textcolor{keyword}{false};}
\DoxyCodeLine{242         this-\/>m\_isDone = \textcolor{keyword}{false};}
\DoxyCodeLine{243     \}}
\DoxyCodeLine{244 }
\DoxyCodeLine{245     std::vector<std::unique\_ptr<std::thread>> m\_threads;}
\DoxyCodeLine{246     std::vector<std::shared\_ptr<std::atomic<bool>>> m\_flags;}
\DoxyCodeLine{247     detail::ThreadQueue<std::function<void(\textcolor{keywordtype}{int} \textcolor{keywordtype}{id})> *> m\_threadPool;}
\DoxyCodeLine{248     std::atomic<bool> m\_isDone;}
\DoxyCodeLine{249     std::atomic<bool> m\_isStop;}
\DoxyCodeLine{250     std::atomic<int> m\_waitingThreadAmount; \textcolor{comment}{// how many threads are waiting}}
\DoxyCodeLine{251 }
\DoxyCodeLine{252     std::mutex m\_mutex;}
\DoxyCodeLine{253     std::condition\_variable m\_threadPoolCondition;}
\DoxyCodeLine{254 \};}
\DoxyCodeLine{255 }
\DoxyCodeLine{256 \} \textcolor{comment}{// namespace UniEngine}}

\end{DoxyCode}
